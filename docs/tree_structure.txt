============================
Django MPTT's Tree Structure
============================

This document provides details about the tree structure used by Django
MPTT in its implementation of Modified Preorder Tree Traversal (MPTT).

.. contents::

Tree fields
===========

Each ``Model`` instance in a Django MTTP tree has the following
information associated with it.

Not all of these fields are **required** to implement a tree structure;
in fact, some are present so we can **avoid** looking at the tree
structure in part or at all when performing certain operations.

Edge indicators
---------------

**"Left" and "right" values which describe a path through a tree which
yields the tree's nodes in depth-first order.**

These are the real meat of MPTT, and the means by which we can
efficiently retrieve trees of data. A lot of the work performed by
``TreeManager`` involves managing these values as the tree structure
changes.

The need for this extra maintenance work is weighed against the fact
that they can be used to:

   * Retrieve entire ordered trees to any level with a single query.
   * Retrieve all descendants of a particular node with a single query.
   * Retrieve all ancestors of a particular node with a single query.
   * Determine how many descendants a node has.

Django MPTT takes care of the heavy lifting for you, but for details
of what these fields represent and how they can be used, have a look
at some of the articles about MPTT which are freely available on the
Internet. For example:

    * `Storing Hierarchical Data in a Database`_
    * `Managing Hierarchical Data in MySQL`_

.. _`Storing Hierarchical Data in a Database`: http://www.sitepoint.com/print/hierarchical-data-database
.. _`Managing Hierarchical Data in MySQL`: http://dev.mysql.com/tech-resources/articles/hierarchical-data.html

Tree identifier
---------------

**A unique identifier assigned to each root node and inherited by all its
descendants.**

This identifier is the means by which Django MPTT implements multiple
root nodes.

Since we have this simple means of identifying all the nodes which
belong to a particular tree, each root node can have its left edge
indicator starting at ``1``. We don't have to worry about overlapping
left and right values with nodes in other trees as long as tree
operations are restricted using the appropriate tree id(s).

This approach limits the number of rows affected when making space to
insert new nodes and removing gaps left by deleted nodes, by avoiding
the problems described in `multiple root nodes without a tree id`_
below.

This field is also used to implement arbitrary ordering of root nodes.
When you create a ``QuerySet`` using ``TreeManager``, it is
automatically ordered by tree id then left value (for depth-first
ordering). When a new root node is created, it is assigned the
next-largest tree id available, so by default trees are displayed in the
order they were created.

When you use the node movement API to make a node a sibling of a root,
tree ids are shuffled around to acheive the new ordering. However, since
*every* node has a tree id, this can result in a large number of rows
being modified when you move a node a long way.

Parent
------

**A node's parent node.**

For our purposes, a node which doesn't have a parent is a "root" node.
All other nodes are "child" nodes.

This field can be used to:

   * Retrieve root nodes only.
   * Determine if a node is a root node or a child node / find a node's
     parent without examining the tree structure.
   * Find a node's immediate children, or number of immediate children,
     (using the `backwards relation`_ provided by Django's
     `database API`_).

.. _`backwards relation`: http://www.djangoproject.com/documentation/db-api/#backward
.. _`database API`: http://www.djangoproject.com/documentation/db-api/

Level
-----

**The level (or "depth") at which a node sits in the tree.**

Root nodes are level ``0``, their immediate children are level ``1``,
*their* immediate children are level ``2`` and so on...

This field is a bit of denormalisation for convenience. It avoids the
need to examine the tree structure to determine the level of a
particular node and makes queries which need to take depth into account
easier to implement. For example, limiting the number of levels of nodes
which are retrieved for the whole tree or any subtree::

   # Retrieve root nodes and their immediate children only
   SomeModel.tree.filter(level__lte=1)

   # Retrieve descendants of a node up to two levels below it
   node.get_descendants().filter(level__lte=node.level + 2)

Alternatives
============

Alternatives to the choices Django MPTT has made in its implementation.

Multiple root nodes without a tree id
-------------------------------------

Another means of implementing multiple root nodes is simply to ensure
that the left and right edge indicators of each root node don't overlap.
When inserting a new root node, its left and right edge indicators
should be set to higher values than the current maximum right value in
the entire tree.

A drawback of this approach is that when performing any operation which
requires that you make space for new nodes to be inserted, if left
and right root node edges are numbered consecutively (i.e a root node's
left value is ``1`` greater than the preceding root node's right value),
you must update every node whose root node has left and right
values greater than that of the tree being operated on, to avoid an
overlap.

This can be worked around by leaving gaps between root nodes - however,
if the tree grows sufficiently to fill the gap left, you're back to the
drawback described above.
